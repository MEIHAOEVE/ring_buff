### ğŸ” ring_buff â€” è½»é‡çº§ç¯å½¢ç¼“å†²åŒºåº“

---

## âœ¨ æ ¸å¿ƒç‰¹æ€§

- âœ… **æ— é”è®¾è®¡**  
  é€‚ç”¨äºå•ç”Ÿäº§è€…/å•æ¶ˆè´¹è€…åœºæ™¯ï¼ˆå¦‚ï¼šISR å†™å…¥ + ä¸»å¾ªç¯è¯»å–ï¼‰ã€‚
- âœ… **é›¶æ‹·è´æ‰¹é‡è¯»å†™**  
  æ”¯æŒé«˜æ•ˆ `memcpy` æ‰¹é‡æ“ä½œï¼Œé¿å…ä¸å¿…è¦çš„æ•°æ®å¤åˆ¶ã€‚
- âœ… **è‡ªåŠ¨ç¯ç»•å¤„ç†**  
  æ•°æ®å†™è‡³ç¼“å†²åŒºæœ«å°¾æ—¶ï¼Œè‡ªåŠ¨å›ç»•åˆ°èµ·å§‹ä½ç½®ã€‚
- âœ… **å®Œæ•´å‚æ•°æ ¡éªŒ**  
  å¯¹ç©ºæŒ‡é’ˆã€éæ³•å°ºå¯¸ç­‰å¼‚å¸¸è¾“å…¥æä¾›å®‰å…¨é˜²æŠ¤ã€‚
- âœ… **ç»Ÿä¸€æ¥å£å°è£…**  
  é€šè¿‡ `ring_buffer_ops_t` æä¾›ç±»é¢å‘å¯¹è±¡é£æ ¼çš„è°ƒç”¨æ–¹å¼ã€‚
- âœ… **é™„å¸¦å®Œæ•´å•å…ƒæµ‹è¯•**  
  è¦†ç›–è¾¹ç•Œæ¡ä»¶ã€å‹åŠ›æµ‹è¯•ã€ç¯ç»•å†™å…¥ç­‰å…³é”®åœºæ™¯ã€‚
- âœ… **å…¼å®¹ Doxygen**  
  æ³¨é‡Šè§„èŒƒï¼Œæ”¯æŒä¸€é”®ç”Ÿæˆä¸“ä¸š API æ–‡æ¡£ã€‚

---

## ğŸ“Œ é‡è¦è¯´æ˜

### 1. ç¼“å†²åŒºå®¹é‡
- **å®é™…å¯ç”¨å®¹é‡ = `size - 1`**
  - ç¤ºä¾‹ï¼š`size = 16` â†’ æœ€å¤šå­˜å‚¨ **15 å­—èŠ‚**
  - ç¤ºä¾‹ï¼š`size = 2` â†’ æœ€å¤šå­˜å‚¨ **1 å­—èŠ‚**
- æ­¤è®¾è®¡ç”¨äºæ— æ­§ä¹‰åœ°åŒºåˆ†â€œç©ºâ€ä¸â€œæ»¡â€çŠ¶æ€ï¼ˆæ ‡å‡†ç¯å½¢ç¼“å†²åŒºå®ç°ï¼‰ã€‚

### 2. çº¿ç¨‹å®‰å…¨æ¨¡å‹

| åœºæ™¯                 | å®‰å…¨æ€§ | è¯´æ˜                             |
|----------------------|--------|----------------------------------|
| å•å†™ + å•è¯»          | âœ… å®‰å…¨ | å¦‚ UART ISR å†™ï¼Œä¸»å¾ªç¯è¯»         |
| å¤šå†™ æˆ– å¤šè¯»         | âŒ ä¸å®‰å…¨ | éœ€å¤–éƒ¨äº’æ–¥é”ï¼ˆmutexï¼‰ä¿æŠ¤       |
| `head` / `tail` å˜é‡ | `volatile` | ç¡®ä¿ä¸­æ–­ä¸ä¸»ç¨‹åºé—´å†…å­˜å¯è§æ€§ |

### 3. å¤šæ ¸ç³»ç»Ÿæ³¨æ„äº‹é¡¹
- **Cortex-M å•æ ¸ï¼ˆå¦‚ STM32ï¼‰**ï¼š`volatile` å·²è¶³å¤Ÿï¼Œæ— éœ€é¢å¤–å±éšœã€‚  
- **å¤šæ ¸ç³»ç»Ÿï¼ˆå¦‚ SMP Linuxã€å¤šæ ¸ MCUï¼‰**ï¼šéœ€é…åˆå†…å­˜å±éšœæˆ–åŸå­æ“ä½œä½¿ç”¨ã€‚

---

## ğŸ“¦ ä½¿ç”¨ç¤ºä¾‹

```c
#include "ring_buffer.h"

// 1. ç”¨æˆ·åˆ†é…å­˜å‚¨ç©ºé—´
uint8_t buffer[64];

// 2. å£°æ˜ç¼“å†²åŒºæ§åˆ¶ç»“æ„
ring_buffer_t rb;

// 3. è·å–æ“ä½œæ¥å£
const ring_buffer_ops_t *ops = ring_buffer_get_ops();

// 4. åˆå§‹åŒ–ï¼ˆsize å¿…é¡» â‰¥ 2ï¼‰
ops->init(&rb, buffer, 64);

// 5. å†™å…¥æ•°æ®
ops->write(&rb, 0xAA);                     // å•å­—èŠ‚å†™å…¥
uint8_t data[] = {1, 2, 3, 4};
ops->write_multi(&rb, data, sizeof(data)); // æ‰¹é‡å†™å…¥

// 6. è¯»å–æ•°æ®
uint8_t byte;
if (ops->read(&rb, &byte)) {
    // æˆåŠŸè¯»å–ä¸€ä¸ªå­—èŠ‚
}

uint8_t recv[10];
uint16_t n = ops->read_multi(&rb, recv, 10); // æœ€å¤šè¯»å– 10 å­—èŠ‚
