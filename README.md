# 🔁 ring_buff — 轻量级环形缓冲区库


---



## ✨ 核心特性

- ✅ **无锁设计**  
  适用于单生产者/单消费者场景（如：ISR 写入 + 主循环读取）。
- ✅ **零拷贝批量读写**  
  支持高效 `memcpy` 批量操作，避免不必要的数据复制。
- ✅ **自动环绕处理**  
  数据写至缓冲区末尾时，自动回绕到起始位置。
- ✅ **完整参数校验**  
  对空指针、非法尺寸等异常输入提供安全防护。
- ✅ **统一接口封装**  
  通过 `ring_buffer_ops_t` 提供类面向对象风格的调用方式。
- ✅ **附带完整单元测试**  
  覆盖边界条件、压力测试、环绕写入等关键场景。
- ✅ **兼容 Doxygen**  
  注释规范，支持一键生成专业 API 文档。

---



## 📌 重要说明

### 1. 缓冲区容量
- **实际可用容量 = `size - 1`**
  - 示例：`size = 16` → 最多存储 **15 字节**
  - 示例：`size = 2` → 最多存储 **1 字节**
- 此设计用于无歧义地区分“空”与“满”状态（标准环形缓冲区实现）。

### 2. 线程安全模型

| 场景                 | 安全性 | 说明                             |
|----------------------|--------|----------------------------------|
| 单写 + 单读          | ✅ 安全 | 如 UART ISR 写，主循环读         |
| 多写 或 多读         | ❌ 不安全 | 需外部互斥锁（mutex）保护       |
| `head` / `tail` 变量 | `volatile` | 确保中断与主程序间内存可见性 |

### 3. 多核系统注意事项
- **Cortex-M 单核（如 STM32）**：`volatile` 已足够，无需额外屏障。  
- **多核系统（如 SMP Linux、多核 MCU）**：需配合内存屏障或原子操作使用。

---



## 🔬环形缓冲区原理

### 空/满状态判断

```
容量 = 16 (size)
实际可用 = 15 (size - 1)

初始状态（空）：
  head = 0, tail = 0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
   ↑
  head/tail

写入 3 字节：
  head = 3, tail = 0
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │A│B│C│ │ │ │ │ │ │ │ │ │ │ │ │ │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
   ↑     ↑
  tail  head

满状态：
  head = 15, tail = 0 (写入 15 字节后)
  ┌─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┬─┐
  │X│X│X│X│X│X│X│X│X│X│X│X│X│X│X│ │
  └─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┘
   ↑                             ↑
  tail                          head
  
  判断：(head + 1) % size == tail → 满
```

### 环绕处理

```c
// 批量写入时自动分段
if (head + len > size) {
    // 第一段：写到末尾
    memcpy(&buffer[head], data, size - head);
    // 第二段：从头开始
    memcpy(&buffer[0], &data[size - head], len - (size - head));
} else {
    // 一次性写入
    memcpy(&buffer[head], data, len);
}
```

---



## 📦 使用示例

```c
#include "ring_buffer.h"

// 1. 用户分配存储空间
uint8_t buffer[64];

// 2. 声明缓冲区控制结构
ring_buffer_t rb;

// 3. 获取操作接口
const ring_buffer_ops_t *ops = ring_buffer_get_ops();

// 4. 初始化（size 必须 ≥ 2）
ops->init(&rb, buffer, 64);

// 5. 写入数据
ops->write(&rb, 0xAA);                     // 单字节写入
uint8_t data[] = {1, 2, 3, 4};
ops->write_multi(&rb, data, sizeof(data)); // 批量写入

// 6. 读取数据
uint8_t byte;
if (ops->read(&rb, &byte)) {
    // 成功读取一个字节
}

uint8_t recv[10];
uint16_t n = ops->read_multi(&rb, recv, 10); // 最多读取 10 字节

```



## 🤝 贡献指南

欢迎提交 Issue 和 Pull Request！

- 🐛 报告 Bug
- 💡 提出新功能建议
- 📖 改进文档
- ✨ 提交代码优化

------



## 📮 联系方式

- **作者**：CRITTY.熙影
- **日期**：2024-12-27
- **版本**：1.1

